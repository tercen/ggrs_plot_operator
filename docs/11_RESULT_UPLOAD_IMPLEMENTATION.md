# Result Upload Implementation (Phase 8)

**Status**: ✅ COMPLETE (2025-01-09)

## Overview

Phase 8 implements the complete result upload workflow, allowing the operator to save generated PNG plots back to Tercen. The implementation follows the same pattern as Python/R clients, using FileService for uploads and maintaining the full Tercen model format.

## Key Components

### 1. Result DataFrame Structure

The result table contains the following columns:

```
.ci                    (int32)   - Column facet index (0 for single plot)
.ri                    (int32)   - Row facet index (0 for single plot)
.content               (string)  - Base64-encoded PNG data
{namespace}.filename   (string)  - File name (e.g., "plot.png")
{namespace}.mimetype   (string)  - MIME type ("image/png")
{namespace}.plot_width (f64)     - Plot width in pixels
{namespace}.plot_height(f64)     - Plot height in pixels
```

**Note**: `.ci` and `.ri` enable multi-facet plot support (future feature). Currently both are set to 0.

### 2. Base64 Encoding with Chunking

Large PNG images are automatically chunked at 1MB boundaries:

```rust
const CHUNK_SIZE: usize = 1_000_000; // 1MB

if base64_len > CHUNK_SIZE {
    // Split into multiple rows with same .ci/.ri
    let chunks: Vec<String> = png_base64
        .as_bytes()
        .chunks(CHUNK_SIZE)
        .map(|chunk| String::from_utf8(chunk.to_vec()).unwrap())
        .collect();
}
```

All chunks share the same `.ci` and `.ri` values, allowing Tercen to reconstruct the complete image.

### 3. Full Tercen Model Format

**Critical Discovery**: The upload must use the **full Tercen model format**, not a simplified format.

#### What We Initially Tried (❌ Failed)

```json
{
  "cols": [
    {"name": "column_name", "type": 105, "data": [...]}
  ],
  "meta_data": {"name": "uuid"}
}
```

This simplified "Sarno format" was rejected by the server.

#### What Actually Works (✅ Success)

```json
{
  "kind": "OperatorResult",
  "tables": [
    {
      "kind": "Table",
      "nRows": 1,
      "properties": {
        "kind": "TableProperties",
        "name": "",
        "sortOrder": [],
        "ascending": true
      },
      "columns": [
        {
          "kind": "Column",
          "id": "",
          "name": ".content",
          "type": "string",
          "nRows": 1,
          "size": 1,
          "metaData": {
            "kind": "ColumnSchemaMetaData",
            "sort": [],
            "ascending": true,
            "quartiles": [],
            "properties": []
          },
          "cValues": {
            "kind": "CValues"
          },
          "values": ["base64..."]
        }
      ]
    }
  ],
  "joinOperators": []
}
```

This matches the structure generated by Python's `toJson()` methods.

### 4. Python toJson/fromJson Pattern

Python client has auto-generated base classes with toJson/fromJson:

```python
# In tercen/model/base.py (auto-generated)
class TableBase(BaseObject):
    def toJson(self):
        m = super().toJson()
        m['kind'] = 'Table'
        m['nRows'] = self.nRows
        m['properties'] = self.properties.toJson()
        m['columns'] = [col.toJson() for col in self.columns]
        return m
```

**For Rust**: No equivalent auto-generated code exists. We manually construct the TSON structure to match Python's output.

### 5. Two-Path Upload Logic

The implementation handles both scenarios:

#### Path 1: Empty fileResultId (Webapp/Test Scenario)

```rust
if existing_file_result_id.is_empty() {
    // Create new FileDocument
    let file_doc = create_file_document(project_id, size);

    // Upload file
    let file_doc_id = upload_result_file(&client, file_doc, result_bytes).await?;

    // Update task with new fileResultId
    update_task_file_result_id(task, &file_doc_id)?;

    // Save task
    let mut task_service = client.task_service()?;
    task_service.update(task.clone()).await?;
}
```

#### Path 2: Existing fileResultId (Normal Operator)

```rust
else {
    // Get existing FileDocument
    let mut file_service = client.file_service()?;
    let file_doc = file_service.get(get_req).await?.into_inner();

    // Upload to existing file
    upload_result_file(&client, file_doc, result_bytes).await?;

    // No task update needed
}
```

This matches the Python client behavior.

### 6. TSON Serialization

The implementation in `src/tercen/result.rs` includes:

- `create_result_dataframe()` - Creates Polars DataFrame with result columns
- `dataframe_to_table()` - Converts DataFrame to proto::Table
- `create_operator_result()` - Wraps table in OperatorResult structure
- `table_to_tercen_tson()` - Serializes Table to full Tercen model TSON format
- `serialize_operator_result()` - Encodes OperatorResult to TSON bytes

The key function `table_to_tercen_tson()` ensures all required fields are present:
- Table: `kind`, `nRows`, `properties`, `columns`
- Properties: `kind`, `name`, `sortOrder`, `ascending`
- Column: `kind`, `id`, `name`, `type`, `nRows`, `size`, `metaData`, `cValues`, `values`

## Key Insights

### Why Empty String for properties.name Works

Initially, we thought empty string for `properties.name` was causing issues. We tried generating UUIDs. But examining Python's working example showed:

```python
'properties': {
    'kind': 'TableProperties',
    'name': '',  # <--- Empty string!
    'sortOrder': [],
    'ascending': True
}
```

**Python uses empty string and it works fine.** The issue was not the empty name - it was the missing structure.

### The Real Problem

We were sending a simplified format without the full model structure. Sarno/Tercen expects:
1. `kind` fields everywhere
2. Full `properties` object
3. Complete `metaData` for each column
4. `cValues` object for each column
5. CamelCase field names (e.g., `nRows` not `n_rows`)

This is Tercen's custom JSON format, not standard protobuf JSON.

## Files Involved

### Core Implementation
- `src/tercen/result.rs` - Complete result upload logic
- `src/tercen/table_convert.rs` - DataFrame to Table conversion
- `src/main.rs` - Calls save_result with plot dimensions

### Supporting
- `Cargo.toml` - Added uuid dependency (later removed as not needed)
- `build.rs` - Proto compilation (tercen_grpc_api submodule)
- `.gitmodules` - Tercen gRPC API submodule

## Testing

The implementation was tested with:

1. **Local Tercen instance** (http://127.0.0.1:50051)
2. **Test workflow** with scatter plot (475K rows)
3. **Result verification** in Tercen UI

Results:
- ✅ PNG uploads successfully
- ✅ Result appears in Tercen UI
- ✅ Downloadable from UI
- ✅ Linked to correct data step

## Performance

- Base64 encoding: Fast (< 100ms for typical plots)
- Result upload: Fast (< 1s for < 1MB images)
- Total overhead: Minimal compared to plot generation time

## Future Enhancements

1. **Multi-facet support**: Currently `.ci` and `.ri` are hardcoded to 0
2. **Metadata customization**: Allow operators to set custom properties
3. **Alternative formats**: Support SVG, PDF output
4. **Compression**: Consider gzip compression for large images

## References

- Python client: `/home/thiago/workspaces/tercen/projects/current_main/tercen_python_client`
- Sarno save result: `/home/thiago/workspaces/tercen/main/sci/sci_relation_vm/lib/src/sarno/save_result.dart`
- Tercen model: `/home/thiago/workspaces/tercen/projects/current_main/tercen_python_client/tercen/model/base.py`
