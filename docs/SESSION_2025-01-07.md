# Session 2025-01-07: GPU Backend Memory Optimization

**Date**: January 7, 2025
**Focus**: Investigating and resolving excessive GPU memory usage

## Objectives
- [x] Investigate why GPU backend uses 314 MB vs CPU's 49 MB (6.4x overhead)
- [x] Identify the source of memory allocations
- [x] Optimize GPU backend configuration
- [x] Document findings and recommendations

## Initial State

### Memory Usage Comparison
- **CPU Backend**: 49 MB peak, stable
- **GPU Backend (Vulkan)**: 314 MB peak, 6.4x more than CPU
- **Question**: Why such high GPU memory overhead?

### Files
- `ggrs/crates/ggrs-core/src/render_v2.rs` - Main rendering implementation
- `ggrs/crates/ggrs-core/src/renderer/webgpu.rs` - WebGPU backend
- `test_local.sh` - Memory profiling script (5ms sampling)

## Investigation Process

### Step 1: Memory Profiling Setup

Added detailed DEBUG MEM tracking throughout the codebase:

1. **render_v2.rs**:
   - Before/after WebGPU initialization
   - Before/after each render_points_gpu call
   - Around vertex upload and render operations

2. **webgpu.rs**:
   - GPU instance creation
   - Adapter request
   - Device and queue creation
   - Render pipeline creation
   - Output texture creation
   - Each render pass
   - Staging buffer creation

### Step 2: Identified Two Major Memory Jumps

Running with Vulkan backend revealed:

**Jump 1: GPU Driver Initialization**
```
Before "Creating GPU instance":        36 MB
After "Requesting GPU adapter":       133 MB
After "WebGPU init complete":         173 MB
Jump size: +137 MB
```

**Jump 2: First Render Call**
```
Before "Uploading vertices":          174 MB
After upload, before render:          305 MB
Jump size: +131 MB
```

Total GPU overhead: ~268 MB

### Step 3: Optimization Attempts

#### Attempt 1: Disable Validation Layers
**Hypothesis**: Debug validation layers are causing overhead

**Change**:
```rust
let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
    backends: wgpu::Backends::all(),
    flags: wgpu::InstanceFlags::empty(), // Disable DEBUG and VALIDATION
    dx12_shader_compiler: Default::default(),
    gles_minor_version: Default::default(),
});
```

**Result**: âŒ NO EFFECT
- GPU init still +137 MB
- First render still +131 MB
- Memory overhead is NOT from validation layers

#### Attempt 2: Minimal Device Limits
**Hypothesis**: Large buffer limits are pre-allocating memory

**Change**:
```rust
required_limits: wgpu::Limits::downlevel_defaults(),
memory_hints: wgpu::MemoryHints::Performance,
```

**Result**: âŒ NO EFFECT
- Memory usage unchanged
- Limits don't affect driver initialization overhead

#### Attempt 3: Switch to OpenGL Backend âœ…
**Hypothesis**: Vulkan has higher driver overhead than OpenGL

**Change**:
```rust
backends: wgpu::Backends::GL, // Use OpenGL instead of Vulkan
```

**Result**: âœ… MAJOR SUCCESS!
- GPU init: +137 MB â†’ **+97 MB** (40 MB saved)
- First render: +131 MB â†’ **+12 MB** (119 MB saved)
- Total peak: 314 MB â†’ **162 MB** (152 MB saved, 49% reduction!)

## Final Results

### Memory Comparison

| Backend | Peak Memory | vs CPU | GPU Init | First Render | Stable |
|---------|------------|--------|----------|--------------|--------|
| CPU (Cairo) | 49 MB | 1.0x | N/A | N/A | ~49 MB |
| GPU (Vulkan) | 314 MB | 6.4x | +137 MB | +131 MB | ~312 MB |
| GPU (OpenGL) | **162 MB** | **3.3x** | **+97 MB** | **+12 MB** | **~159 MB** |

### Performance Comparison

| Backend | Render Time | Speedup | Memory |
|---------|-------------|---------|--------|
| CPU | 3.1s | 1.0x | 49 MB |
| GPU (OpenGL) | 0.5s | **10x** | 162 MB |

**Conclusion**: OpenGL provides 10x speedup with 3.3x memory overhead - acceptable trade-off

## Root Cause Analysis

### Memory Overhead Breakdown (OpenGL)

1. **GPU Driver Initialization (~97 MB)**
   - Driver internal state
   - Shader compilation caches
   - Command buffer pre-allocation
   - OpenGL context setup

2. **Render Pipeline Resources (~12 MB)**
   - Staging buffers for CPUâ†”GPU transfers (1.6 MB per batch)
   - Render targets and texture caches
   - Command encoder buffers

3. **Application Data (~53 MB)**
   - Base process memory (2 MB)
   - GGRS library overhead
   - Data streaming buffers
   - Cairo surface for compositing

**Total**: 162 MB peak

### Why Vulkan Uses More Memory

Vulkan is a lower-level API designed for maximum control and performance:
- Larger driver state machines
- Explicit command buffer management (pre-allocates large buffers)
- Validation layers have higher overhead even when disabled
- More complex pipeline state objects

OpenGL is higher-level and more memory-efficient for simple use cases:
- Driver manages command buffers implicitly
- Smaller state machine
- Less pre-allocation
- Better suited for our rendering pattern (batch uploads + simple draws)

## Implementation Changes

### File: `ggrs/crates/ggrs-core/src/renderer/webgpu.rs`

**Line 88**: Changed backend from Vulkan to OpenGL
```rust
backends: wgpu::Backends::GL, // Use OpenGL instead of Vulkan
```

**Line 89**: Disabled debug flags
```rust
flags: wgpu::InstanceFlags::empty(), // Disable DEBUG and VALIDATION flags
```

**Lines 112-113**: Used minimal device limits
```rust
required_limits: wgpu::Limits::downlevel_defaults(),
memory_hints: wgpu::MemoryHints::Performance,
```

### Configuration: `operator_config.json`

Users can choose backend:
```json
{
  "backend": "gpu",  // "cpu" or "gpu"
  "chunk_size": 15000,
  "default_plot_width": 800,
  "default_plot_height": 600
}
```

## Testing

### Test Command
```bash
./test_local.sh
```

### Memory Profile Output
- CSV file: `memory_usage_backend_gpu.csv` (238 samples)
- Chart: `memory_usage_backend_gpu.png`
- Statistics:
  - Mean: 137 MB
  - Median: 156 MB
  - Peak: 162 MB

### Validation
- âœ… Plot renders correctly
- âœ… No memory leaks (stable at 159 MB during rendering)
- âœ… 10x speedup maintained (0.5s vs 3.1s)
- âœ… 49% memory reduction vs Vulkan

## Documentation Created

1. **`docs/GPU_BACKEND_MEMORY.md`**
   - Complete investigation report
   - Memory comparison tables
   - Root cause analysis
   - Implementation details
   - Testing procedures

2. **Updated `CLAUDE.md`**
   - Added GPU backend section
   - Updated memory statistics
   - Added performance comparison table
   - Added documentation reference

3. **Memory Profile Files**
   - `memory_usage_backend_gpu.csv` (OpenGL)
   - `memory_usage_backend_gpu.png` (chart)
   - `memory_usage_backend_cpu.csv` (baseline)

## Recommendations

### When to Use GPU Backend
- Large datasets (>100K points)
- Interactive visualization requirements
- Systems with available GPU memory (>200 MB)
- Performance is critical

### When to Use CPU Backend
- Memory-constrained environments (<150 MB available)
- Small datasets (<50K points)
- Systems without GPU/OpenGL support
- Memory is more critical than speed

### Future Optimizations (Not Pursued)

These were considered but not necessary:

1. **Release Build**: May reduce memory slightly but didn't pursue
2. **Smaller Staging Buffers**: Would require multiple transfers per batch
3. **Texture Reuse**: Already implemented (resize reuses texture)
4. **Custom Allocator**: Vulkan-specific, doesn't help with OpenGL

## Lessons Learned

1. **Backend matters**: Vulkan vs OpenGL makes a 152 MB difference
2. **Driver overhead is unavoidable**: Can't eliminate GPU initialization cost
3. **Validation layers aren't the issue**: Disabling them had no effect
4. **Profiling is essential**: Memory tracking revealed the actual bottlenecks
5. **Simple is better**: OpenGL's higher-level API is more efficient for our use case

## Next Steps

1. âœ… Document GPU backend optimization
2. âœ… Update CLAUDE.md with GPU information
3. âœ… Add TODO for render.rs â†’ render_v2.rs migration
4. ðŸ“‹ **Phase 8**: Implement result upload to Tercen
5. ðŸ“‹ **Phase 9**: Production polish and testing

## Files Modified

### Modified
- `ggrs/crates/ggrs-core/src/renderer/webgpu.rs` - OpenGL backend, minimal limits
- `CLAUDE.md` - Added GPU backend section and updated statistics

### Created
- `docs/GPU_BACKEND_MEMORY.md` - Complete investigation report
- `docs/SESSION_2025-01-07.md` - This session document
- `memory_usage_backend_gpu.csv` - OpenGL memory profile
- `memory_usage_backend_gpu.png` - Memory chart

### Test Files
- `test_local.sh` - Memory profiling script (existing)
- `operator_config.json` - Backend configuration (existing)

## Summary

Successfully reduced GPU memory overhead by 49% (314 MB â†’ 162 MB) by switching from Vulkan to OpenGL backend. The 3.3x memory overhead vs CPU (162 MB vs 49 MB) is acceptable given the 10x performance improvement (0.5s vs 3.1s for 475K points). Investigation revealed that GPU driver initialization and command buffer management are the main sources of overhead, which cannot be eliminated without sacrificing GPU acceleration.
